### Python 提高 

1.  GIL锁 
 -  由于历史原因在Cpython虚拟机(解释器)，难以移除GIL  
 - GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码  
- 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）
- Python使用多进程是可以利用多核的CPU资源的
    -  计算密集型：进程
    -  I/O操作型：线程、协程 
- 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁 

2. 深拷贝和浅拷贝
  - 浅拷贝是对于一个对象的顶层拷贝，拷贝了引用，并没有拷贝内容 
  - 深拷贝是对于一个对象所有层次的拷贝(递归) 
  - 分片表达式可以赋值一个序列 
  -  字典的copy 

3.  私有化 
 - 父类中属性名为__名字的，子类不继承，子类不能访问
    -  Pythoneer认为开放比私有好，因为可以通过 **_类名__属性名** 访问，只是重载了一个类名
    -  可以通过__dict__魔术方法，类或者对象的所有属性 
    -  个人开发中喜欢用 _方法来表示方法是告诉自己是私有的
 - 如果在子类中向__名字赋值，那么会在子类中定义的一个与父类相同名字的属性
- _名的变量、函数、类在使用from xxx import *时都不会被导入  

4.  封装、继承、多态 （面向对象设计）
   - Python变量作用域 LEGB
     - L —— Local(function)；函数内的名字空间
     - E —— Enclosing function locals；外部嵌套函数的名字空间(例如closure)
     - G —— Global(module)；函数定义所在模块（文件）的名字空间
     - B —— Builtin(Python)；Python内置模块的名字空间  

- 为啥要封装 ？ 
  -  将变量 + 函数 制作成一个模板
  -  解决并发程序中会出现对同一个全局变量操作的问题

- 为啥要继承？
  -  多类的功能进行扩充和适当修改 
  - 继承能够有效的进行代码的管理，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往不需要就修改 

- 怎样理解多态？ 
   -  调用同一个方法，输出不同 

- 多继承以及MRO顺序 
   - super().__init__相对于类名__init__，在单继承上用法基本无差 
   - 多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错 
   - 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错 

5. 静态方法和类方法   
  - 类属性、实例属性
      - 实例属性属于对象 
      -  类属性属于类 

  - 实例方法、静态方法和类方法 
  三种方法在内存中都归属于类，区别在于调用方式不同 
    - 实例方法：由对象调用；至少一个self参数；执行实例方法 时，自动将调用该方法的对象赋值给self；
    - 类方法@classmethod：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls；
    - 静态方法@staticmethod：由类调用；无默认参数  

6.  property属性 
-  一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法 
   - 定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数
  - 调用时，无需括号  
  - property属性内部进行一系列的逻辑计算，最终将计算结果返回 

-  property属性的有两种方式 
   - 装饰器 即：在方法上应用装饰器 
   - 类属性 即：在类中定义值为property对象的类属性 

- 装饰器方式
   - 新式类中的属性有三种访问方式，并分别对应了三个被@property（经典类，只具有）、@方法名.setter、@方法名.deleter修饰的方法 
   - 分别将三个方法定义为对同一个属性：获取、修改、删除  

 - 类属性方式：创建值为property对象的类属性 
    - help(property) 
    - 由于类属性方式创建property属性具有3种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除 

-  property属性-应用 
   -  使用property升级getter和setter方法 
   - 使用property取代getter和setter方法 

7. 魔术方法 
    -  表示类的描述信息__doc__  
    -  表示当前操作的对象在那个模块__module__  
    - 表示当前操作的对象的类是什么__class__  
    - 初始化方法，通过类创建对象时，自动触发执行,与__new__构成析构函数 
    - 当对象在内存中被释放时，自动触发执行__del__ 
    - 对象后面加括号【对象() 或者 类()()】，触发执行__call__，
    - 类或对象中的所有属性__dict__  
    - 用于索引操作，如字典。以上分别表示获取、设置、删除数据__getitem__和__setitem__及__delitem__ 
    - 该三个方法用于分片操作，如：列表__getslice__和__setslice__及__delslice__  

8.  with与“上下文管理器”  
  - 系统资源如文件、数据库连接、socket 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭（断开）该资源 
  - 任何实现了__enter__() 和__exit__() 方法的对象都可称之为上下文管理器 
  - Python 还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在__enter__ 方法中执行，yield 之后的语句在__exit__ 方法中执行。紧跟在 yield 后面的值是函数的返回值。


9.  闭包 
- 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包 
- 对象的方法obj() ,类似类对象定义__call__函数  
- nonlocal关键字（LEGB） 
  ```
  x = 300
  def dd():
      x = 200
      def inner():
          nonlocal x
          print(f"{x}")
      return inner 
  ```
- 思考：函数、匿名函数、闭包、对象 当做实参时有什么区别？
   - 匿名函数： 简单的基本功能，传递是这个函数的引用 ，只有功能
   - 普通函数 ：较为复杂的功能，传递是这个函数的引用 ，只有功能 
   - 闭包：较为复杂的功能那个，传递的是这个闭包中的函数以及数据，因此传递是功能+数据 
   - 对象：最为复杂的功能，传递是很多数据+很多功能，因此传递的是功能+数据


10. 装饰器 
@装饰器名func    
def dd()  
等价于  dd = func(dd)   
dd()本质上等于被装饰函数dd先作为参数赋值给func后，装饰器闭包函数里面执行dd()  

-  装饰器示例
   - 无参数的函数 
   - 被装饰的函数有参数 
   - 被装饰的函数有不定长参数 
   - 装饰器中的return 
   - 装饰器带参数,在原有装饰器的基础上，设置外部变量 （**有点难，得搞懂）
   - 类装饰器
- 装饰器(decorator)功能
   - 引入日志
   - 函数执行时间统计
   - 执行函数前预备处理
   - 执行函数后清理功能
   - 权限校验等场景
   - 缓存 

11. 元类 （理解即可）

[python中的元类和abc.ABCMeta实现的虚类](https://www.jianshu.com/p/06c960020322)
- 类也是个对象 
- 当定义一个函数、类、全局变量时，其实就是创建一个"对象"，然后再globals获取的这个字典中添加一个名字，让这个名字指向刚刚创建的对象空间而已 

- 元类就是用来创建类的“东西” ，元类就是类的类
  ```
  MyClass = MetaClass() # 使用元类创建出一个对象，这个对象称为“类”
  my_object = MyClass() # 使用“类”来创建出实例对象
  ```
- type就是Python在背后用来创建所有类的元类 ,Python的所有东西都是对象，都是通过type创建的 
- 元类的主要目的就是为了当创建类时能够自动地改变类
    - 拦截类的创建
    - 修改类
    - 返回修改之后的类 
- abc.ABCMeta
ABCMeta就是让你的类变成一个纯虚类，子类必须实现某个方法，这个方法在父类中用@abc.abstractmethod修饰 


12. 元类实现ORM（提高） 
ORM 是 python编程语言后端web框架 Django的核心思想，“Object Relational Mapping”，即对象-关系映射，简称ORM。

