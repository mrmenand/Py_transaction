# Python并发编程之多线程从入门到放弃 
一直觉的，对高并发的业务处理能力是非常重要的，怎么合理利用计算机的性能，这是很关键，如果有机会就研究下分布式部署框架结构 


## Some Troubles 

### 概念
- 并行：同时做某些事，可以互不干扰的同一时刻做几件事。 
- 并发：也是同时做某些事，但是强调，同一时刻做了几件事。
- 同步：函数或方法被调用的时候，调用者直接最终的结果。 
- 异步 ： 不直接得到最终结果。
- 阻塞：函数或方法调用的时候，立即返回。
- 非阻塞：不立即返回 
- 区别 ： 并行和并发强调是同时性，同步、异步强调的是结果，阻塞和非阻塞强调的是时间，是否等待

### 并发的解决 
1.  队列、缓冲区 
   - 排队就是队列，先进先出。排队是一种解决并发的方法
   - 排成的队列，其实就是一个缓冲地带，就是缓冲区 

2. 优先队列 

3. 争抢 
   - 资源被一个线程占据后，就会锁定资源，其它线程就需要等该线程释放资源再进程争抢。这是一种锁机制。 

4. 预处理 
   - 提前加载线程需要的数据，缓存场景常用 

5. 垂直扩展 
    - 比如一台服务器无法快速处理高并发业务时，可以提升该服务器的内存、增加CPU性能和CPU数，这就是垂直扩展。 

6. 水平扩展 
    -  也可以叫横向扩展，当一台服务器无法满足业务时，就增加服务器数量、带宽，这就是水平扩展。 

7. 消息中间件
   - 使用消息队列 




## 多任务-线程 

Python里面实现多线程需要用到threading库，其中每一个Thread类的实例控制一个线程 

### Thread类、线程启动、线程的传参、线程退出、threading属性、Thread实例的属性、getName()和setName()、线程的start()和run()方法
`def __init__(self, group=None, target=None, name=None,          args=(), kwargs=None, *, daemon=None):`

- 线程执行代码的封装  
   - python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。
   - start() --> run() --> _target() 

-  线程的执行顺序 
   - 多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。
   - 每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。
   - 当线程的run()函数执行完毕，线程自动结束，或者是线程内的函数抛出为处理的异常（raise）。
   - 无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式 

-  多线程-共享全局变量（**）
   - 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据   
   - 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全） 
   - 如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确  

- 同步就是协同步调，按预定的先后次序进行运行，通过线程同步解决资源竞争问题 
-  互斥锁 
   -  当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制 
   - 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性 
   - 锁的好处：确保了某段关键代码只能由一个线程从头到尾完整地执行 
   -  锁的坏处：
      - 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
      - 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁 

- 死锁 
   - 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁  
   - 避免死锁
     - 程序设计时要尽量避免（银行家算法）
     -  添加超时时间等


#### 多任务-进程 
- 程序：例如xxx.py这是程序，是一个静态的 
- 一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元 
- multiprocessing模块
   - 跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情  
   - 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动 
   - 进程pid 
   -  进程间不同享全局变量 

- 进程、线程的区别 
  - 进程是系统进行资源分配和调度的一个独立单位 
  - 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位 
  - 一个程序至少有一个进程,一个进程至少有一个线程. 
  - 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高 
  - 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 
  - 线程不能够独立执行，必须依存在进程中 
  - 可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人  

- 进程间通信-Queue 
可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序  

- 进程池Pool  
初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务  


### 多任务-协程  

- 生成器 
  - 使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器）
  - yield关键字：
     - 保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起
      - 将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用
      - 可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数） 
     - 使用send唤醒  

- 协程Coroutine
  - 比线程更小占用更小执行单元，自带CPU上下文
  - 在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定
  - 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作 
  - 协程的切换只是单纯的操作CPU的上下文 

- greenlet
   - python中的greenlet模块对其封装，从而使得切换任务变的更加简单 

- gevent 
   - 比greenlet更强大的并且能够自动切换任务的模块gevent 
   - 其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。 